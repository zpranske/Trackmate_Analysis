%{ 
 Paradis Lab Trackmate Pipeline v2
 Rev. 3/6/2024 Zach Pranske

 This code is designed to process XML files generated by the Trackmate 
 particle tracking suite. The input is a folder containing one or more XML
 files generated by the main Save function in Trackmate. The output is a
 variety of information including useful graphs, particle mobility data,
 and split/merge information.

 This pipeline uses the built-in functions trackmateEdges,
 trackmateFeatureDeclarations, trackmateGraph, trackmateImageCalibration,
 trackmateSpots, and importTrackMateTracks in the Trackmate Github repo.
 Additional documentation on these functions is found in the Trackmate
 manual.

 Before using, raw live images should be denoised (if desired) and bleach 
 corrected, and ROIs should be defined prior to running in Trackmate. All
 Trackmate parameters should be recorded and all XML files for a project 
 should be saved in one folder.
%}

%% Define global variables
global path output_path start_frame end_frame frame_range sample_rate;

%% Image-specific parameters -- check before each project

%Define number of timepoints per image
sample_rate = 4; %Number of acquisitions per minute
start_frame = 0; end_frame = 241;
frame_range = start_frame:end_frame;

%Define directories and file paths for input and output
addpath('C:\Users\zpranske\Documents\GitHub\Trackmate_Analysis');
path = uigetdir('C:\Users\zpranske\Desktop\Seif\test xmls for seif\XMLs');
mkdir(path,'output')
output_path = [path filesep 'output' filesep];

file_pattern = fullfile(path, '*.xml'); % Change to whatever pattern you need.
filenames_list = dir(file_pattern);

%Loop to go through all XMLs in a folder
skip_flag = false; ask=1;
for k = 1 : length(filenames_list)
    filename = filenames_list(k).name;
    file_path = fullfile(filenames_list(k).folder, filename);
    disp(['Now processing file ' filename '...'])
    
    %Check to see if the XML has already been processed by checking if a
    %"Variables from ..." matlab file exists in the folder
    %If XML has not been processed, process it
    if ~exist([output_path 'Variables from ' filename '.mat'])
        [spot_table,spot_ID_map,edge_map,G] = processTMoutputs(filename,file_path);
    %If XML has been processed, ask if user wants to reprocess XML or use
    %saved workspace variables from previous processing
    else
        if ~skip_flag
            ask = input(['Found data for this file. Load existing workspace variables or reprocess? 1=use existing, 2=reprocess \n' ...
                'WARNING: selecting reprocess will replace all workspace variables and results files ' ...
                'in the working folder. \nProcessing may take up to several minutes per file. ']);
            y = input(['Do this for the rest of the files? 1=yes 2=no ']);
            %If user wants to do same thing (reprocess vs. use existing
            %variables) for all files, skip this dialog for rest of folder
            if y==1; skip_flag=true; end
        end
        if ask==1 %Load existing workspace variables
            load([output_path 'Variables from ' filename '.mat']);
        else      %Reprocess file
            [spot_table,spot_ID_map,edge_map,G] = processTMoutputs(filename,file_path);
        end
    end  
    
    %% Custom analysis of Trackmate outputs
    
    %Process edges for custom analysis 
    %This step occurs after all inbuilt Trackmate functions have been run
    edgeinfo = process_edges(spot_table,edge_map,frame_range,filename);
    writetable(edgeinfo, [output_path 'Edge Table from ' filename '.csv']);   
    
    % Graph connectivity of edges (should reveal info about splits and merges)
    f = figure;
    hp = plot(G,'layout','layered');
    set(hp, 'YData', G.Nodes.FRAME);
    set(gca, 'YDir', 'reverse', 'XColor', 'none');
    ylabel('Time point');
    box off;
    savefig(f,[output_path 'Map of ' filename '.fig']);
    
    %Analyze splits and merges and write to fiel
    t_removed = analyze_split_merge(G,filename,path);
    writematrix(t_removed, [output_path 'Survival curve from ' filename '.csv']);
end

beep; disp(['All files successfully processed!'])

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% FUNCTIONS NEEDED FOR THIS THING TO WORK PROPERLY %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% Run all the inbuilt Trackmate functions for processing spots and edges 
function[spot_table,spot_ID_map,edge_map,G] = processTMoutputs(filename,file_path)
    global output_path;
    disp(['Analyzing spots for ' filename '...'])
    [spot_table, spot_ID_map] = trackmateSpots(file_path);
    writetable(spot_table, [output_path 'Spot Table of ' filename '.csv']);
    disp(['Analyzing edges for ' filename '...'])
    edge_map = trackmateEdges(file_path);
    G = trackmateGraph(file_path, [], [], true);
    save([output_path 'Variables from ' filename '.mat']);
end

%% Pull out info about edges (e.g. individual particles) and analyze
function [edgeinfo] = process_edges(spot_table,edge_map,frame_range,filename)
    global output_path sample_rate;
    track_names = edge_map.keys;
    edgeinfo = table();
    
    %Get a table of spot info for all spots that comprise each edge
    %A spot is a single particle at a single timepoint
    for i = 1:edge_map.Count
        edges_i = edge_map(track_names{i});
        spot_ids_i = edges_i.SPOT_SOURCE_ID;
        spot_rows_i = ismember(spot_table.ID, spot_ids_i); %List the rows in the spot table to pull for this edge        
        edge_info_i = spot_table(spot_rows_i,:);

        % HERE IS THE MAIN SPOT INFO TABLE FOR EDGE i
        edge_info_i = edge_info_i(ismember(edge_info_i.FRAME,frame_range),:);
        %If specifying a frame range, this cuts down the edge table to
        %include only frames within that range
        edges_i = edges_i(ismember(edge_info_i.FRAME,frame_range),:);

        if(height(edge_info_i)>0)
            start_frame = edge_info_i.FRAME(1);
            end_frame = edge_info_i.FRAME(end);
            %Get number of spots in this edge, i.e. length of the track
            n_spots = height(edge_info_i);        

            %Calculate displacement of the particle
            startx_i = edges_i.EDGE_X_LOCATION(1);
            endx_i = edges_i.EDGE_X_LOCATION(end);
            starty_i = edges_i.EDGE_Y_LOCATION(1);
            endy_i = edges_i.EDGE_Y_LOCATION(end);
            % Compute euclidean distance between start and end points
            total_disp_i = sqrt((endx_i-startx_i)^2 + (endy_i-starty_i)^2);
            % Compute total distance traveled by summing the individual
            % displacement values between frames
            total_distance_i = sum(edges_i.DISPLACEMENT);
            meandering = total_distance_i/total_disp_i;
            % Now pull info about the spots that comprise this track. For 
            % instance, look at first and last spots in this edge to find 
            % when it was detected (for time subanalysis, e.g. look at 
            % first 10 mins of each image) or find how many spots are in 
            % this track
            mean_spot_intensity = mean(edge_info_i.MEAN_INTENSITY);
            mean_quality = mean(edge_info_i.QUALITY);
            mean_signoise = mean(edge_info_i.SNR);
            mean_contrast = mean(edge_info_i.CONTRAST);
            duration_mins = (start_frame-end_frame)/sample_rate;
            
            % Write edge info to table 
            edgeinfo(i,:) = table(string(filename),double(i), n_spots, ...
                start_frame, end_frame, duration_mins, total_disp_i, ...
                total_distance_i, meandering, mean_quality, ...
                mean_spot_intensity, ...
                mean_signoise, ...
                mean_contrast);
        end
    end
    edgeinfo = renamevars(edgeinfo, ["Var1" "Var2"], ["filename" "n_track"]);
end

function [t_removed] = analyze_split_merge(G,filename,path)
    global output_path start_frame end_frame;
    %Get list of nodes with indegree 0 and outdegree >0 (indicating it is a
    %parent node)
    parent_nodes = find(indegree(G)==0 & outdegree(G)>0);

    %Get number of parent nodes with a downstream split (the number of
    %particles that split, regardless of how many times they split)
    n_tracks_w_split = 0;
    survival = [];
    for i=1:length(parent_nodes)
        %Check parent node to see if it splits and add to counter if yes
        children = nearest(G,parent_nodes(i),Inf);
        doesitsplit = max(outdegree(G,children))>1;
        if doesitsplit
            n_tracks_w_split = n_tracks_w_split + 1;
        end
        %Check how long each path "survives" i.e. how many frames it is
        %tracked for
        P = shortestpath(G,parent_nodes(i),children(end));
        survival(i)=length(P);
    end
    
    %Generate survival curves for each parent node
    survival = sort(survival');
    gc = groupcounts(survival);
    survival = [unique(survival) gc];
    t_removed = [];
    n_frames = end_frame-start_frame;
    p = 0; %Initialize number to remove from each timepoint
    for i=1:n_frames
        if ~(isempty(find(survival(:,1)==i)));
            idx = find(survival(:,1)==i);
            subtract = survival(idx,2);
            p=p+subtract;
        end
        t_removed(i) = length(parent_nodes)-p;
    end
    t_removed = t_removed';

    n_tracks_total = length(parent_nodes);
    percent_split = n_tracks_w_split / n_tracks_total;

    %Get TOTAL number of splitting events
    n_splits = sum(outdegree(G)>1);
    n_merges = sum(indegree(G)>1);
    
    fileID = fopen([output_path 'Split info from ' filename '.txt'],'w');
        fprintf(fileID,['n_tracks_total' '\t' int2str(n_tracks_total) '\n']);
        fprintf(fileID,['n_tracks_w_split' '\t' int2str(n_tracks_w_split) '\n']);
        fprintf(fileID,['percent_split' '\t' num2str(percent_split) '\n']);
        fprintf(fileID,['n_splits_total' '\t' int2str(n_splits) '\n']);
        fprintf(fileID,['n_merges_total' '\t' int2str(n_merges) '\n']);
    fclose(fileID);
end

%% DISPLAY SPOT CLOUD IN MATLAB
%Use to make sure it matches with Fiji and has spots in ROIs only

%     x = spot_table.POSITION_X;
%     y = spot_table.POSITION_Y;
%     figure;
%     plot(x, y, 'k.');
%     axis equal;
%     units = 'um'; %char(spot_table.Properties.VariableUnits(22));
%     xlabel(['X (' units ')']);
%     ylabel(['Y (' units ')']);
%     hold on;

%% Import edge track table

%Sample code to highlight a specific track on the graph

% x = edge1.POSITION_X;
% y = edge1.POSITION_Y;
% plot(x, y, 'bx')
% units = 'um'; %char(spot_table.Properties.VariableUnits(22));
% xlabel(['X (' units ')'])
% ylabel(['Y (' units ')'])
% x1 = edge1.POSITION_X(1);
% y1 = edge1.POSITION_Y(1);
% plot(x1,y1,'go')
% x_end = edge1.POSITION_X(end);
% y_end = edge1.POSITION_Y(end);
% plot(x_end,y_end,'ro')
